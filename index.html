<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Buddhist Solar Time</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 2rem;
      background-color: #f0f8ff;
    }
    input, button {
      padding: 0.5rem;
      font-size: 1rem;
      margin: 0.5rem 0;
    }
    #result {
      margin-top: 1rem;
      font-size: 1.1rem;
    }
  </style>
</head>
<body>
  <h1>Buddhist Solar Time</h1>
  <p>Enter a city to find out the current time, solar time and the gap between the two.</p>
  <input type="text" id="cityInput" placeholder="Example: Barcelona" />
  <button onclick="getSolarTime()">Get solar time</button>
  <p id="result"></p>

  <script>
    const OPEN_CAGE_KEY = '2a34668ed89b4673a8cfc466fe9ffb1c'; // ← Reemplaza con tu clave de OpenCage

    // Aproximación de la ecuación del tiempo (en minutos)
    function getEquationOfTime(dayOfYear) {
      const B = (360 / 365) * (dayOfYear - 81) * Math.PI / 180;
      const EoT = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
      return EoT; // en minutos
    }

    function formatOffsetMinutes(minutes) {
      const sign = minutes < 0 ? "-" : "+";
      const absMin = Math.abs(minutes);
      const hrs = Math.floor(absMin / 60);
      const min = Math.round(absMin % 60);
      return `${sign}${hrs} h ${min} min`;
    }

    async function getSolarTime() {
      const city = document.getElementById('cityInput').value.trim();
      const resultDiv = document.getElementById('result');

      if (!city) {
        resultDiv.textContent = "Please enter a city.";
        return;
      }

      resultDiv.textContent = "Calculating...";

      try {
        // 1. Obtener coordenadas y zona horaria
        const geoRes = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(city)}&key=${OPEN_CAGE_KEY}`);
        const geoData = await geoRes.json();

        if (!geoData.results.length) {
          resultDiv.textContent = "City not found.";
          return;
        }

        const { lat, lng } = geoData.results[0].geometry;
        const timezone = geoData.results[0].annotations.timezone.name;
        const offset = geoData.results[0].annotations.timezone.offset_sec / 3600;

        // 2. Obtener hora local actual en la ciudad
        const nowUTC = new Date();
        const nowLocal = new Date(nowUTC.toLocaleString("en-US", { timeZone: timezone }));

        // 3. Día del año
        const startOfYear = new Date(Date.UTC(nowLocal.getFullYear(), 0, 0));
        const diff = nowLocal - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);

        // 4. Ecuación del tiempo y corrección por longitud
        const eot = getEquationOfTime(dayOfYear); // minutos
        const standardMeridian = offset * 15; // grados
        const longitudeCorrection = 4 * (standardMeridian - lng); // minutos

        const totalCorrection = eot + longitudeCorrection;

        // 5. Calcular hora solar (restar la corrección)
        const solarTimeMs = nowLocal.getTime() - totalCorrection * 60 * 1000;
        const solarTime = new Date(solarTimeMs);

        // 6. Diferencia entre hora oficial y solar
        const timeDiffMin = Math.round((nowLocal - solarTime) / (1000 * 60));

        resultDiv.innerHTML = `
          <strong>${city}</strong><br />
          Current time: <strong>${nowLocal.toLocaleTimeString()}</strong><br />
          True solar time: <strong>${solarTime.toLocaleTimeString()}</strong><br />
          Solar flakes: <strong>${formatOffsetMinutes(timeDiffMin)}</strong>
        `;
      } catch (err) {
        console.error(err);
        resultDiv.textContent = "Error calculating solar time.";
      }
    }
  </script>
</body>
</html>

